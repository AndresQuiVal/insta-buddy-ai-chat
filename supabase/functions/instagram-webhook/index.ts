
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import "https://deno.land/x/xhr@0.1.0/mod.ts";

interface SupabaseClient {
  from: (table: string) => any;
  functions: {
    invoke: (name: string, options?: any) => Promise<any>;
  };
  rpc: (fn: string, params?: any) => Promise<any>;
}

const createSupabaseClient = (): SupabaseClient => {
  const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
  const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
  
  const headers = {
    'apikey': supabaseKey,
    'Authorization': `Bearer ${supabaseKey}`,
    'Content-Type': 'application/json',
  };

  return {
    from: (table: string) => ({
      select: (columns = '*') => ({
        eq: (column: string, value: any) => ({
          single: async () => {
            const url = `${supabaseUrl}/rest/v1/${table}?select=${columns}&${column}=eq.${value}`;
            const response = await fetch(url, { headers });
            const data = await response.json();
            return { data: data[0] || null, error: response.ok ? null : data };
          },
          async execute() {
            const url = `${supabaseUrl}/rest/v1/${table}?select=${columns}&${column}=eq.${value}`;
            const response = await fetch(url, { headers });
            const data = await response.json();
            return { data, error: response.ok ? null : data };
          }
        }),
        async execute() {
          const url = `${supabaseUrl}/rest/v1/${table}?select=${columns}`;
          const response = await fetch(url, { headers });
          const data = await response.json();
          return { data, error: response.ok ? null : data };
        }
      }),
      insert: (values: any) => ({
        select: (columns = '*') => ({
          single: async () => {
            const url = `${supabaseUrl}/rest/v1/${table}`;
            const response = await fetch(url, {
              method: 'POST',
              headers: { ...headers, 'Prefer': 'return=representation' },
              body: JSON.stringify(values)
            });
            const data = await response.json();
            return { data: data[0] || null, error: response.ok ? null : data };
          }
        })
      }),
      update: (values: any) => ({
        eq: (column: string, value: any) => ({
          select: (columns = '*') => ({
            single: async () => {
              const url = `${supabaseUrl}/rest/v1/${table}?${column}=eq.${value}`;
              const response = await fetch(url, {
                method: 'PATCH',
                headers: { ...headers, 'Prefer': 'return=representation' },
                body: JSON.stringify(values)
              });
              const data = await response.json();
              return { data: data[0] || null, error: response.ok ? null : data };
            }
          })
        })
      })
    }),
    functions: {
      invoke: async (name: string, options: any = {}) => {
        const url = `${supabaseUrl}/functions/v1/${name}`;
        const response = await fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify(options.body || {})
        });
        const data = await response.json();
        return { data, error: response.ok ? null : data };
      }
    },
    rpc: async (fn: string, params: any = {}) => {
      try {
        const url = `${supabaseUrl}/rest/v1/rpc/${fn}`;
        const response = await fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify(params)
        });
        
        const text = await response.text();
        console.log(`üì° RPC ${fn} response text:`, text);
        
        let data;
        if (text.trim() === '') {
          // Handle empty response (void functions)
          data = null;
        } else {
          try {
            data = JSON.parse(text);
          } catch (parseError) {
            console.error(`‚ùå JSON Parse error for RPC ${fn}:`, parseError);
            console.error(`üìã Response text:`, text);
            throw new Error(`Invalid JSON response from RPC ${fn}: ${text}`);
          }
        }
        
        return { data, error: response.ok ? null : { message: `RPC ${fn} failed`, status: response.status } };
      } catch (error) {
        console.error(`üí• RPC ${fn} error:`, error);
        return { data: null, error: error.message };
      }
    }
  };
};

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabase = createSupabaseClient();
    const body = await req.json()
    
    console.log('üì® ===== NUEVO WEBHOOK RECIBIDO =====')
    console.log('üìã Webhook completo:', JSON.stringify(body, null, 2))

    if (body.object !== 'instagram') {
      return new Response(
        JSON.stringify({ message: 'Not an Instagram webhook' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    if (body.entry && Array.isArray(body.entry) && body.entry.length > 0) {
      if (body.entry[0].id === '17841406338417419' && body.entry[0].time) {
        console.log('‚úÖ Webhook verificado')
        return new Response(body.entry[0].id, { status: 200 })
      }
    }

    if (body.entry && Array.isArray(body.entry)) {
      for (const entry of body.entry) {
        console.log('üîÑ ===== PROCESANDO ENTRY =====')
        console.log('üìã Entry ID:', entry.id)

        if (entry.changes) {
          console.log('üîÑ ===== PROCESANDO CAMBIOS =====')
          for (const change of entry.changes) {
            console.log('üîÑ ===== PROCESANDO CAMBIO =====')
            console.log('üìã Change:', JSON.stringify(change, null, 2))
          }
        }

        if (entry.messaging) {
          console.log('üìù PROCESANDO MENSAJES DIRECTOS')
          
          for (const messagingEvent of entry.messaging) {
            console.log('üìù Processing messaging event:', JSON.stringify(messagingEvent, null, 2))
            
            const senderId = messagingEvent.sender.id
            const recipientId = messagingEvent.recipient.id
            const messageText = messagingEvent.message?.text
            const timestamp = new Date(messagingEvent.timestamp).toISOString()
            const messageId = messagingEvent.message?.mid
            const isEcho = messagingEvent.message?.is_echo === true

            console.log('üöÄ === PROCESANDO MENSAJE PARA AUTORESPONDER ===')
            console.log('üë§ SENDER ID:', senderId)
            console.log('üí¨ MENSAJE:', messageText)

            // Skip si es un echo (mensaje que yo envi√©)
            if (isEcho) {
              console.log('‚è≠Ô∏è Mensaje no v√°lido o es un echo - saltando')
              continue
            }

            // Actualizar actividad del prospecto - con manejo mejorado de errores
            console.log('üîÑ Actualizando actividad del prospecto...')
            try {
              const { error: activityError } = await supabase.rpc('update_prospect_activity', { 
                p_prospect_id: senderId 
              })
              
              if (activityError) {
                console.error('‚ùå Error actualizando actividad:', activityError)
              } else {
                console.log('‚úÖ Actividad del prospecto actualizada')
              }
            } catch (activityErr) {
              console.error('üí• Error en update_prospect_activity:', activityErr)
              // Continue processing even if activity update fails
            }

            // ===== BUSCAR USUARIO DE INSTAGRAM =====
            console.log('üîç ===== BUSCANDO USUARIO DE INSTAGRAM =====')
            console.log('üìã Recipient ID (Instagram Business Account):', recipientId)

            const { data: instagramUser, error: userError } = await supabase
              .from('instagram_users')
              .select('*')
              .eq('instagram_user_id', recipientId)
              .single()

            if (userError || !instagramUser) {
              console.error('‚ùå Usuario de Instagram no encontrado:', userError)
              continue
            }

            console.log('‚úÖ Usuario encontrado:', JSON.stringify(instagramUser, null, 2))

            // ===== CREAR O ACTUALIZAR PROSPECTO =====
            console.log('üîç ===== CREANDO/ACTUALIZANDO PROSPECTO =====')
            
            let prospectId;
            try {
              const { data: prospectResult, error: prospectError } = await supabase.rpc('create_or_update_prospect', {
                p_instagram_user_id: instagramUser.id,
                p_prospect_instagram_id: senderId,
                p_username: `prospect_${senderId.slice(-8)}`, // Username temporal
                p_profile_picture_url: null
              })

              if (prospectError) {
                console.error('‚ùå Error creando prospecto:', prospectError)
                continue
              }

              prospectId = prospectResult
              console.log('‚úÖ Prospecto creado/actualizado:', prospectId)
            } catch (prospectErr) {
              console.error('üí• Error en create_or_update_prospect:', prospectErr)
              continue
            }

            // ===== GUARDAR MENSAJE DEL PROSPECTO =====
            try {
              const { data: messageResult, error: messageError } = await supabase.rpc('add_prospect_message', {
                p_prospect_id: prospectId,
                p_message_instagram_id: messageId,
                p_message_text: messageText,
                p_is_from_prospect: true,
                p_message_timestamp: timestamp,
                p_message_type: 'text',
                p_raw_data: messagingEvent
              })

              if (messageError) {
                console.error('‚ùå Error guardando mensaje:', messageError)
              } else {
                console.log('‚úÖ Mensaje del prospecto guardado en BD')
              }
            } catch (messageErr) {
              console.error('üí• Error en add_prospect_message:', messageErr)
            }

            // ===== AN√ÅLISIS DEL MENSAJE =====
            console.log('üîç ===== AN√ÅLISIS DEL MENSAJE =====')
            console.log('üìù Texto:', messageText)

            const isInvitation = messageText.toLowerCase().includes('invitacion') || messageText.toLowerCase().includes('invitaci√≥n')
            const isPresentation = messageText.toLowerCase().includes('presentacion') || messageText.toLowerCase().includes('presentaci√≥n')
            const isInscription = messageText.toLowerCase().includes('inscripcion') || messageText.toLowerCase().includes('inscripci√≥n')

            // ===== GUARDAR MENSAJE EN INSTAGRAM_MESSAGES =====
            const { error: saveError } = await supabase
              .from('instagram_messages')
              .insert({
                instagram_user_id: instagramUser.id,
                instagram_message_id: messageId,
                sender_id: senderId,
                recipient_id: recipientId,
                message_text: messageText,
                message_type: 'received',
                timestamp: timestamp,
                is_invitation: isInvitation,
                is_presentation: isPresentation,
                is_inscription: isInscription,
                raw_data: messagingEvent
              })

            if (saveError) {
              console.error('‚ùå Error guardando mensaje en instagram_messages:', saveError)
            } else {
              console.log('‚úÖ Mensaje guardado correctamente con relaci√≥n al usuario')
            }

            console.log('üìä Tipos detectados guardados:', { isInvitation: isInvitation, isPresentation: isPresentation, isInscription: isInscription })

            // ===== NOTIFICAR CAMBIOS AL DASHBOARD =====
            console.log('üîÑ ===== NOTIFICANDO CAMBIOS AL DASHBOARD =====')
            try {
              await supabase.functions.invoke('dashboard-sync', {
                body: { type: 'message_received', senderId, messageText }
              })
              console.log('‚úÖ Cambios notificados al dashboard')
            } catch (notifyError) {
              console.log('‚ö†Ô∏è Error notificando al dashboard (no cr√≠tico):', notifyError)
            }

            // ===== OBTENER AUTORESPONDERS =====
            console.log('üîç === OBTENIENDO AUTORESPONDERS ===')
            
            console.log('üì° Consultando autoresponders desde endpoint...')
            const { data: autoresponderResponse, error: autoresponderError } = await supabase.functions.invoke('get-autoresponders', {})
            
            console.log('üìä Respuesta del endpoint:', JSON.stringify(autoresponderResponse, null, 2))

            if (autoresponderError || !autoresponderResponse?.success) {
              console.error('‚ùå Error obteniendo autoresponders:', autoresponderError)
              continue
            }

            const autoresponders = autoresponderResponse.autoresponders || []
            console.log('‚úÖ Autoresponders obtenidos:', autoresponders.length)

            console.log('üìã Lista de autoresponders:', autoresponders.map(ar => ({
              id: ar.id,
              name: ar.name,
              is_active: ar.is_active,
              message_preview: ar.message_text?.substring(0, 30) + '...',
              use_keywords: ar.use_keywords,
              keywords: ar.keywords
            })))

            let selectedAutoresponder = null

            for (const autoresponder of autoresponders) {
              if (!autoresponder.use_keywords) {
                selectedAutoresponder = autoresponder
                break
              }

              const keywords = autoresponder.keywords || []
              let hasMatch = false

              for (const keyword of keywords) {
                console.log(`üîç Verificando palabra clave "${keyword}" -> ${messageText.toLowerCase().includes(keyword.toLowerCase()) ? 'COINCIDE' : 'NO COINCIDE'}`)
                if (messageText.toLowerCase().includes(keyword.toLowerCase())) {
                  hasMatch = true
                  break
                }
              }

              if (hasMatch) {
                console.log(`‚úÖ Autoresponder "${autoresponder.name}" tiene coincidencia de palabras clave - COINCIDE`)
                selectedAutoresponder = autoresponder
                break
              } else {
                console.log(`‚ùå Autoresponder "${autoresponder.name}" NO tiene coincidencia de palabras clave - NO COINCIDE`)
              }
            }

            if (!selectedAutoresponder) {
              console.log('‚ùå No se encontr√≥ autoresponder que coincida')
              continue
            }

            console.log('üéØ AUTORESPONDER SELECCIONADO:')
            console.log('üìã ID:', selectedAutoresponder.id)
            console.log('üìã Nombre:', selectedAutoresponder.name)
            console.log('üìã Mensaje:', selectedAutoresponder.message_text)
            console.log('üìã Solo primer mensaje:', selectedAutoresponder.send_only_first_message)
            console.log('üìã Usa palabras clave:', selectedAutoresponder.use_keywords)
            console.log('üìã Palabras clave:', selectedAutoresponder.keywords)

            // Verificar si ya se envi√≥ autoresponder
            console.log('üîç Verificando si ya se le envi√≥ autoresponder a:', senderId)

            const { data: alreadySent } = await supabase
              .from('autoresponder_sent_log')
              .select('*')
              .eq('sender_id', senderId)
              .eq('autoresponder_message_id', selectedAutoresponder.id)

            if (selectedAutoresponder.send_only_first_message && alreadySent && alreadySent.length > 0) {
              console.log('‚è≠Ô∏è Ya se envi√≥ este autoresponder - saltando')
              continue
            }

            console.log('üÜï PRIMERA VEZ QUE ESCRIBE - ENVIANDO')

            // Enviar autoresponder
            console.log('üöÄ ENVIANDO AUTORESPONDER...')

            console.log('üì§ ===== ENVIANDO MENSAJE VIA EDGE FUNCTION =====')
            console.log('üë§ Recipient:', senderId)
            console.log('üíå Message:', selectedAutoresponder.message_text)
            console.log('üÜî Instagram User ID:', recipientId)

            const { data, error } = await supabase.functions.invoke('instagram-send-message', {
              body: {
                recipient_id: senderId,
                message_text: selectedAutoresponder.message_text,
                instagram_user_id: recipientId
              }
            })

            console.log('üì® Respuesta de instagram-send-message:')
            console.log('üìã Data:', JSON.stringify(data, null, 2))
            console.log('üìã Error:', error)

            if (error) {
              console.error('‚ùå Error enviando mensaje:', error)
              continue
            }

            console.log('‚úÖ ===== MENSAJE ENVIADO EXITOSAMENTE VIA EDGE FUNCTION =====')
            console.log('‚úÖ AUTORESPONDER ENVIADO EXITOSAMENTE')

            // Registrar env√≠o en log
            await supabase
              .from('autoresponder_sent_log')
              .insert({
                autoresponder_message_id: selectedAutoresponder.id,
                sender_id: senderId,
                sent_at: new Date().toISOString()
              })

            console.log('‚úÖ Autoresponder guardado en BD del prospecto')

            // Guardar el autoresponder enviado tambi√©n en prospect_messages
            try {
              await supabase.rpc('add_prospect_message', {
                p_prospect_id: prospectId,
                p_message_instagram_id: data?.message_id || `auto_${Date.now()}`,
                p_message_text: selectedAutoresponder.message_text,
                p_is_from_prospect: false,
                p_message_timestamp: new Date().toISOString(),
                p_message_type: 'autoresponder',
                p_raw_data: { autoresponder_id: selectedAutoresponder.id, sent_via: 'webhook' }
              })
              console.log('‚úÖ Autoresponder guardado en prospect_messages')
            } catch (autoMsgError) {
              console.error('‚ö†Ô∏è Error guardando autoresponder en prospect_messages (no cr√≠tico):', autoMsgError)
            }

            console.log('‚úÖ === MENSAJE PROCESADO COMPLETAMENTE ===')
          }
        } else {
          console.log('‚ùå No hay changes en este entry')
        }
      }
    }

    return new Response(JSON.stringify({ success: true }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    })

  } catch (error) {
    console.error('üí• Error en webhook:', error)
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    })
  }
})
